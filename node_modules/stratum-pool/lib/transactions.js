var bitcoin = require('bitcoinjs-lib-zcash');
var util = require('./util.js');

// public members
var txHash;

exports.txHash = function(){
  return txHash;
};

function scriptCompile(addrHash){
    script = bitcoin.script.compile(
        [
            bitcoin.opcodes.OP_DUP,
            bitcoin.opcodes.OP_HASH160,
            addrHash,
            bitcoin.opcodes.OP_EQUALVERIFY,
            bitcoin.opcodes.OP_CHECKSIG
        ]);
    return script;
}

// Our founders addresses are regular addresses, not scripts
scriptFoundersCompile = scriptCompile;

/*
// If founders addresses are scripts, use a separate function
function scriptFoundersCompile(address){
    script = bitcoin.script.compile(
        [
            bitcoin.opcodes.OP_HASH160,
            address,
            bitcoin.opcodes.OP_EQUAL
        ]);
    return script;
}
*/

exports.createGeneration = function(rpcData, blockReward, feeReward, recipients, poolAddress, payFoundersReward, percentFoundersReward, maxFoundersRewardBlockHeight, foundersRewardAddressChangeInterval, vFoundersRewardAddress, percentTreasuryReward, treasuryRewardStartBlockHeight, treasuryRewardAddressChangeInterval, vTreasuryRewardAddress){
    var poolAddrHash = bitcoin.address.fromBase58Check(poolAddress).hash;
    var tx = new bitcoin.Transaction();
    var blockHeight = parseInt(rpcData.height);
    // input for coinbase tx
    var serializedBlockHeight;
    if (1 <= blockHeight && blockHeight <= 16) {
        serializedBlockHeight = Buffer.from([0x50 + blockHeight, 0]);
    } else {
        var cbHeightBuff = bitcoin.script.number.encode(blockHeight);
        serializedBlockHeight = new Buffer.concat([
            Buffer.from([cbHeightBuff.length]),
            cbHeightBuff,
            new Buffer('00', 'hex') // OP_0
        ]);
    }

    tx.addInput(new Buffer('0000000000000000000000000000000000000000000000000000000000000000', 'hex'),
        4294967295,
        4294967295,
        new Buffer.concat([serializedBlockHeight,
            Buffer('54686520426974636f696e20524d204d696e696e6720506f6f6c20706f6f6c2e626974636f696e726d2e6f7267', 'hex')])
    );
    // The Bitcoin RM Mining Pool pool.bitcoinrm.org
    // 5a2d4e4f4d50212068747470733a2f2f6769746875622e636f6d2f6a6f7368756179616275742f7a2d6e6f6d70 => Z-NOMP! https://github.com/joshuayabut/z-nomp

    // calculate total fees
    var feePercent = 0;
    for (var i = 0; i < recipients.length; i++) {
        feePercent = feePercent + recipients[i].percent;
    }


    // Start building coinbase transaction, with these outputs:
    // 1st output goes to miner (pool's address)
    // 2nd output goes to founder (if there is founder's reward)
    // 3,4,... outputs go to pool operators (if there is pool fee)
    // last output is dummy segwit transaction

    if ((blockHeight >= 360021 && blockHeight < 1320021) ||
      (blockHeight >= 1920021 && blockHeight < 2640021) ||
      (blockHeight >= 3480021 && blockHeight < 4080021) ||
      (blockHeight >= 5040021 && blockHeight < 5280021)
       ) {

      // We have a founder's reward. So, blockReward MUST BE adjusted

      /*
       Our src/rpc/mining.cpp returns coinbasevalue after deducting foundersreward already
       So to get total blockReward when foundersreward != 0, divide blockReward by (1 - percentTreasuryReward/100)
       Our src/chainparams.cpp is configured to start foundersreward to the last founder's address first
      */

      var index = parseInt(Math.floor(((blockHeight - 2 * treasuryRewardStartBlockHeight) / treasuryRewardAddressChangeInterval) % vTreasuryRewardAddress.length));
      var foundersAddrHash = bitcoin.address.fromBase58Check(vTreasuryRewardAddress[index]).hash;

      // First output of coinbase transaction always goes to the miner (in this case, pool's address)
      tx.addOutput(
        scriptCompile(poolAddrHash),
        Math.round(blockReward * (1 - feePercent / (100 - percentTreasuryReward))) + feeReward
      );

      // Second output of coinbase transaction goes to the founder's address
      // Founder's fee is a percentage of total blockReward, ie, blockReward/(1 - percentTreasuryReward/100)
      tx.addOutput(
        scriptFoundersCompile(foundersAddrHash),
        Math.round(blockReward / (100/percentTreasuryReward - 1))
      );

      // Next output of coinbase transaction goes to pool fees (pool operators that collect pool fees)
      // As pool fee, each pool operator collects a percentage of total blockReward, ie, blockReward/(1 - percentTreasuryReward/100)
      for (var i = 0; i < recipients.length; i++) {
         tx.addOutput(
             scriptCompile(bitcoin.address.fromBase58Check(recipients[i].address).hash),
             Math.round(blockReward * recipients[i].percent / (100 - percentTreasuryReward))
         );
      }
    }
    else {

      // No founder's reward. So, blockReward MUST NOT BE adjusted

      // First output of coinbase transaction always goes to the miner (in this case, pool's address)
      tx.addOutput(
        scriptCompile(poolAddrHash),
        Math.round(blockReward * (1 - (feePercent / 100))) + feeReward
      );

      // Next output of coinbase transaction goes to pool fees (pool operators that collect pool fees)
      for (var i = 0; i < recipients.length; i++) {
        tx.addOutput(
          scriptCompile(bitcoin.address.fromBase58Check(recipients[i].address).hash),
          Math.round(blockReward * (recipients[i].percent / 100))
        );
      }
    }

    // The last output of coinbase transaction is always a dummy SegWit transaction
    if (rpcData.default_witness_commitment !== undefined) {
        tx.addOutput(new Buffer(rpcData.default_witness_commitment, 'hex'), 0);
    }

    txHex = tx.toHex();

    // assign
    txHash = tx.getHash().toString('hex');

    /*
    console.log('===> tx:',tx);
    console.log('txHex: ' + txHex.toString('hex'));
    console.log('txHash: ' + txHash);
    */

    return txHex;
};

module.exports.getFees = function(feeArray){
    var fee = Number();
    feeArray.forEach(function(value) {
        fee = fee + Number(value.fee);
    });
    return fee;
};
